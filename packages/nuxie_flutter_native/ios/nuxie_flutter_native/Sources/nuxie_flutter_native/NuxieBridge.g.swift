// Autogenerated from Pigeon (v26.1.7), do not edit directly.
// See also: https://pub.dev/packages/pigeon

import Foundation

#if os(iOS)
  import Flutter
#elseif os(macOS)
  import FlutterMacOS
#else
  #error("Unsupported platform.")
#endif

/// Error class for passing custom error details to Dart side.
final class PigeonError: Error {
  let code: String
  let message: String?
  let details: Sendable?

  init(code: String, message: String?, details: Sendable?) {
    self.code = code
    self.message = message
    self.details = details
  }

  var localizedDescription: String {
    return
      "PigeonError(code: \(code), message: \(message ?? "<nil>"), details: \(details ?? "<nil>")"
  }
}

private func wrapResult(_ result: Any?) -> [Any?] {
  return [result]
}

private func wrapError(_ error: Any) -> [Any?] {
  if let pigeonError = error as? PigeonError {
    return [
      pigeonError.code,
      pigeonError.message,
      pigeonError.details,
    ]
  }
  if let flutterError = error as? FlutterError {
    return [
      flutterError.code,
      flutterError.message,
      flutterError.details,
    ]
  }
  return [
    "\(error)",
    "\(type(of: error))",
    "Stacktrace: \(Thread.callStackSymbols)",
  ]
}

private func createConnectionError(withChannelName channelName: String) -> PigeonError {
  return PigeonError(code: "channel-error", message: "Unable to establish connection on channel: '\(channelName)'.", details: "")
}

private func isNullish(_ value: Any?) -> Bool {
  return value is NSNull || value == nil
}

private func nilOrValue<T>(_ value: Any?) -> T? {
  if value is NSNull { return nil }
  return value as! T?
}

func deepEqualsNuxieBridge(_ lhs: Any?, _ rhs: Any?) -> Bool {
  let cleanLhs = nilOrValue(lhs) as Any?
  let cleanRhs = nilOrValue(rhs) as Any?
  switch (cleanLhs, cleanRhs) {
  case (nil, nil):
    return true

  case (nil, _), (_, nil):
    return false

  case is (Void, Void):
    return true

  case let (cleanLhsHashable, cleanRhsHashable) as (AnyHashable, AnyHashable):
    return cleanLhsHashable == cleanRhsHashable

  case let (cleanLhsArray, cleanRhsArray) as ([Any?], [Any?]):
    guard cleanLhsArray.count == cleanRhsArray.count else { return false }
    for (index, element) in cleanLhsArray.enumerated() {
      if !deepEqualsNuxieBridge(element, cleanRhsArray[index]) {
        return false
      }
    }
    return true

  case let (cleanLhsDictionary, cleanRhsDictionary) as ([AnyHashable: Any?], [AnyHashable: Any?]):
    guard cleanLhsDictionary.count == cleanRhsDictionary.count else { return false }
    for (key, cleanLhsValue) in cleanLhsDictionary {
      guard cleanRhsDictionary.index(forKey: key) != nil else { return false }
      if !deepEqualsNuxieBridge(cleanLhsValue, cleanRhsDictionary[key]!) {
        return false
      }
    }
    return true

  default:
    // Any other type shouldn't be able to be used with pigeon. File an issue if you find this to be untrue.
    return false
  }
}

func deepHashNuxieBridge(value: Any?, hasher: inout Hasher) {
  if let valueList = value as? [AnyHashable] {
     for item in valueList { deepHashNuxieBridge(value: item, hasher: &hasher) }
     return
  }

  if let valueDict = value as? [AnyHashable: AnyHashable] {
    for key in valueDict.keys { 
      hasher.combine(key)
      deepHashNuxieBridge(value: valueDict[key]!, hasher: &hasher)
    }
    return
  }

  if let hashableValue = value as? AnyHashable {
    hasher.combine(hashableValue.hashValue)
  }

  return hasher.combine(String(describing: value))
}

    

/// Generated class from Pigeon that represents data sent in messages.
struct PConfigureRequest: Hashable {
  var apiKey: String? = nil
  var wrapperVersion: String? = nil
  var usingPurchaseController: Bool? = nil
  var environment: String? = nil
  var apiEndpoint: String? = nil
  var logLevel: String? = nil
  var enableConsoleLogging: Bool? = nil
  var enableFileLogging: Bool? = nil
  var redactSensitiveData: Bool? = nil
  var retryCount: Int64? = nil
  var retryDelaySeconds: Int64? = nil
  var eventBatchSize: Int64? = nil
  var flushAt: Int64? = nil
  var flushIntervalSeconds: Int64? = nil
  var maxQueueSize: Int64? = nil
  var maxCacheSizeBytes: Int64? = nil
  var cacheExpirationSeconds: Int64? = nil
  var featureCacheTtlSeconds: Int64? = nil
  var localeIdentifier: String? = nil
  var isDebugMode: Bool? = nil
  var eventLinkingPolicy: String? = nil
  var maxFlowCacheSizeBytes: Int64? = nil
  var flowCacheExpirationSeconds: Int64? = nil
  var maxConcurrentFlowDownloads: Int64? = nil
  var flowDownloadTimeoutSeconds: Int64? = nil
  var purchaseTimeoutSeconds: Int64? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PConfigureRequest? {
    let apiKey: String? = nilOrValue(pigeonVar_list[0])
    let wrapperVersion: String? = nilOrValue(pigeonVar_list[1])
    let usingPurchaseController: Bool? = nilOrValue(pigeonVar_list[2])
    let environment: String? = nilOrValue(pigeonVar_list[3])
    let apiEndpoint: String? = nilOrValue(pigeonVar_list[4])
    let logLevel: String? = nilOrValue(pigeonVar_list[5])
    let enableConsoleLogging: Bool? = nilOrValue(pigeonVar_list[6])
    let enableFileLogging: Bool? = nilOrValue(pigeonVar_list[7])
    let redactSensitiveData: Bool? = nilOrValue(pigeonVar_list[8])
    let retryCount: Int64? = nilOrValue(pigeonVar_list[9])
    let retryDelaySeconds: Int64? = nilOrValue(pigeonVar_list[10])
    let eventBatchSize: Int64? = nilOrValue(pigeonVar_list[11])
    let flushAt: Int64? = nilOrValue(pigeonVar_list[12])
    let flushIntervalSeconds: Int64? = nilOrValue(pigeonVar_list[13])
    let maxQueueSize: Int64? = nilOrValue(pigeonVar_list[14])
    let maxCacheSizeBytes: Int64? = nilOrValue(pigeonVar_list[15])
    let cacheExpirationSeconds: Int64? = nilOrValue(pigeonVar_list[16])
    let featureCacheTtlSeconds: Int64? = nilOrValue(pigeonVar_list[17])
    let localeIdentifier: String? = nilOrValue(pigeonVar_list[18])
    let isDebugMode: Bool? = nilOrValue(pigeonVar_list[19])
    let eventLinkingPolicy: String? = nilOrValue(pigeonVar_list[20])
    let maxFlowCacheSizeBytes: Int64? = nilOrValue(pigeonVar_list[21])
    let flowCacheExpirationSeconds: Int64? = nilOrValue(pigeonVar_list[22])
    let maxConcurrentFlowDownloads: Int64? = nilOrValue(pigeonVar_list[23])
    let flowDownloadTimeoutSeconds: Int64? = nilOrValue(pigeonVar_list[24])
    let purchaseTimeoutSeconds: Int64? = nilOrValue(pigeonVar_list[25])

    return PConfigureRequest(
      apiKey: apiKey,
      wrapperVersion: wrapperVersion,
      usingPurchaseController: usingPurchaseController,
      environment: environment,
      apiEndpoint: apiEndpoint,
      logLevel: logLevel,
      enableConsoleLogging: enableConsoleLogging,
      enableFileLogging: enableFileLogging,
      redactSensitiveData: redactSensitiveData,
      retryCount: retryCount,
      retryDelaySeconds: retryDelaySeconds,
      eventBatchSize: eventBatchSize,
      flushAt: flushAt,
      flushIntervalSeconds: flushIntervalSeconds,
      maxQueueSize: maxQueueSize,
      maxCacheSizeBytes: maxCacheSizeBytes,
      cacheExpirationSeconds: cacheExpirationSeconds,
      featureCacheTtlSeconds: featureCacheTtlSeconds,
      localeIdentifier: localeIdentifier,
      isDebugMode: isDebugMode,
      eventLinkingPolicy: eventLinkingPolicy,
      maxFlowCacheSizeBytes: maxFlowCacheSizeBytes,
      flowCacheExpirationSeconds: flowCacheExpirationSeconds,
      maxConcurrentFlowDownloads: maxConcurrentFlowDownloads,
      flowDownloadTimeoutSeconds: flowDownloadTimeoutSeconds,
      purchaseTimeoutSeconds: purchaseTimeoutSeconds
    )
  }
  func toList() -> [Any?] {
    return [
      apiKey,
      wrapperVersion,
      usingPurchaseController,
      environment,
      apiEndpoint,
      logLevel,
      enableConsoleLogging,
      enableFileLogging,
      redactSensitiveData,
      retryCount,
      retryDelaySeconds,
      eventBatchSize,
      flushAt,
      flushIntervalSeconds,
      maxQueueSize,
      maxCacheSizeBytes,
      cacheExpirationSeconds,
      featureCacheTtlSeconds,
      localeIdentifier,
      isDebugMode,
      eventLinkingPolicy,
      maxFlowCacheSizeBytes,
      flowCacheExpirationSeconds,
      maxConcurrentFlowDownloads,
      flowDownloadTimeoutSeconds,
      purchaseTimeoutSeconds,
    ]
  }
  static func == (lhs: PConfigureRequest, rhs: PConfigureRequest) -> Bool {
    return deepEqualsNuxieBridge(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNuxieBridge(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PTriggerRequest: Hashable {
  var requestId: String? = nil
  var event: String? = nil
  var properties: [String?: Any?]? = nil
  var userProperties: [String?: Any?]? = nil
  var userPropertiesSetOnce: [String?: Any?]? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PTriggerRequest? {
    let requestId: String? = nilOrValue(pigeonVar_list[0])
    let event: String? = nilOrValue(pigeonVar_list[1])
    let properties: [String?: Any?]? = nilOrValue(pigeonVar_list[2])
    let userProperties: [String?: Any?]? = nilOrValue(pigeonVar_list[3])
    let userPropertiesSetOnce: [String?: Any?]? = nilOrValue(pigeonVar_list[4])

    return PTriggerRequest(
      requestId: requestId,
      event: event,
      properties: properties,
      userProperties: userProperties,
      userPropertiesSetOnce: userPropertiesSetOnce
    )
  }
  func toList() -> [Any?] {
    return [
      requestId,
      event,
      properties,
      userProperties,
      userPropertiesSetOnce,
    ]
  }
  static func == (lhs: PTriggerRequest, rhs: PTriggerRequest) -> Bool {
    return deepEqualsNuxieBridge(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNuxieBridge(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PTriggerUpdate: Hashable {
  var requestId: String? = nil
  var updateKind: String? = nil
  var payload: [String?: Any?]? = nil
  var isTerminal: Bool? = nil
  var timestampMs: Int64? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PTriggerUpdate? {
    let requestId: String? = nilOrValue(pigeonVar_list[0])
    let updateKind: String? = nilOrValue(pigeonVar_list[1])
    let payload: [String?: Any?]? = nilOrValue(pigeonVar_list[2])
    let isTerminal: Bool? = nilOrValue(pigeonVar_list[3])
    let timestampMs: Int64? = nilOrValue(pigeonVar_list[4])

    return PTriggerUpdate(
      requestId: requestId,
      updateKind: updateKind,
      payload: payload,
      isTerminal: isTerminal,
      timestampMs: timestampMs
    )
  }
  func toList() -> [Any?] {
    return [
      requestId,
      updateKind,
      payload,
      isTerminal,
      timestampMs,
    ]
  }
  static func == (lhs: PTriggerUpdate, rhs: PTriggerUpdate) -> Bool {
    return deepEqualsNuxieBridge(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNuxieBridge(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PFeatureAccess: Hashable {
  var allowed: Bool? = nil
  var unlimited: Bool? = nil
  var balance: Int64? = nil
  var type: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PFeatureAccess? {
    let allowed: Bool? = nilOrValue(pigeonVar_list[0])
    let unlimited: Bool? = nilOrValue(pigeonVar_list[1])
    let balance: Int64? = nilOrValue(pigeonVar_list[2])
    let type: String? = nilOrValue(pigeonVar_list[3])

    return PFeatureAccess(
      allowed: allowed,
      unlimited: unlimited,
      balance: balance,
      type: type
    )
  }
  func toList() -> [Any?] {
    return [
      allowed,
      unlimited,
      balance,
      type,
    ]
  }
  static func == (lhs: PFeatureAccess, rhs: PFeatureAccess) -> Bool {
    return deepEqualsNuxieBridge(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNuxieBridge(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PFeatureCheckResult: Hashable {
  var customerId: String? = nil
  var featureId: String? = nil
  var requiredBalance: Int64? = nil
  var code: String? = nil
  var allowed: Bool? = nil
  var unlimited: Bool? = nil
  var balance: Int64? = nil
  var type: String? = nil
  var preview: Any? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PFeatureCheckResult? {
    let customerId: String? = nilOrValue(pigeonVar_list[0])
    let featureId: String? = nilOrValue(pigeonVar_list[1])
    let requiredBalance: Int64? = nilOrValue(pigeonVar_list[2])
    let code: String? = nilOrValue(pigeonVar_list[3])
    let allowed: Bool? = nilOrValue(pigeonVar_list[4])
    let unlimited: Bool? = nilOrValue(pigeonVar_list[5])
    let balance: Int64? = nilOrValue(pigeonVar_list[6])
    let type: String? = nilOrValue(pigeonVar_list[7])
    let preview: Any? = pigeonVar_list[8]

    return PFeatureCheckResult(
      customerId: customerId,
      featureId: featureId,
      requiredBalance: requiredBalance,
      code: code,
      allowed: allowed,
      unlimited: unlimited,
      balance: balance,
      type: type,
      preview: preview
    )
  }
  func toList() -> [Any?] {
    return [
      customerId,
      featureId,
      requiredBalance,
      code,
      allowed,
      unlimited,
      balance,
      type,
      preview,
    ]
  }
  static func == (lhs: PFeatureCheckResult, rhs: PFeatureCheckResult) -> Bool {
    return deepEqualsNuxieBridge(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNuxieBridge(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PFeatureUsageResult: Hashable {
  var success: Bool? = nil
  var featureId: String? = nil
  var amountUsed: Double? = nil
  var message: String? = nil
  var usageCurrent: Double? = nil
  var usageLimit: Double? = nil
  var usageRemaining: Double? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PFeatureUsageResult? {
    let success: Bool? = nilOrValue(pigeonVar_list[0])
    let featureId: String? = nilOrValue(pigeonVar_list[1])
    let amountUsed: Double? = nilOrValue(pigeonVar_list[2])
    let message: String? = nilOrValue(pigeonVar_list[3])
    let usageCurrent: Double? = nilOrValue(pigeonVar_list[4])
    let usageLimit: Double? = nilOrValue(pigeonVar_list[5])
    let usageRemaining: Double? = nilOrValue(pigeonVar_list[6])

    return PFeatureUsageResult(
      success: success,
      featureId: featureId,
      amountUsed: amountUsed,
      message: message,
      usageCurrent: usageCurrent,
      usageLimit: usageLimit,
      usageRemaining: usageRemaining
    )
  }
  func toList() -> [Any?] {
    return [
      success,
      featureId,
      amountUsed,
      message,
      usageCurrent,
      usageLimit,
      usageRemaining,
    ]
  }
  static func == (lhs: PFeatureUsageResult, rhs: PFeatureUsageResult) -> Bool {
    return deepEqualsNuxieBridge(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNuxieBridge(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PProfileResponse: Hashable {
  var raw: [String?: Any?]? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PProfileResponse? {
    let raw: [String?: Any?]? = nilOrValue(pigeonVar_list[0])

    return PProfileResponse(
      raw: raw
    )
  }
  func toList() -> [Any?] {
    return [
      raw
    ]
  }
  static func == (lhs: PProfileResponse, rhs: PProfileResponse) -> Bool {
    return deepEqualsNuxieBridge(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNuxieBridge(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PFeatureAccessChangedEvent: Hashable {
  var featureId: String? = nil
  var from: PFeatureAccess? = nil
  var to: PFeatureAccess? = nil
  var timestampMs: Int64? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PFeatureAccessChangedEvent? {
    let featureId: String? = nilOrValue(pigeonVar_list[0])
    let from: PFeatureAccess? = nilOrValue(pigeonVar_list[1])
    let to: PFeatureAccess? = nilOrValue(pigeonVar_list[2])
    let timestampMs: Int64? = nilOrValue(pigeonVar_list[3])

    return PFeatureAccessChangedEvent(
      featureId: featureId,
      from: from,
      to: to,
      timestampMs: timestampMs
    )
  }
  func toList() -> [Any?] {
    return [
      featureId,
      from,
      to,
      timestampMs,
    ]
  }
  static func == (lhs: PFeatureAccessChangedEvent, rhs: PFeatureAccessChangedEvent) -> Bool {
    return deepEqualsNuxieBridge(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNuxieBridge(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PFlowLifecycleEvent: Hashable {
  var type: String? = nil
  var flowId: String? = nil
  var reason: String? = nil
  var timestampMs: Int64? = nil
  var payload: [String?: Any?]? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PFlowLifecycleEvent? {
    let type: String? = nilOrValue(pigeonVar_list[0])
    let flowId: String? = nilOrValue(pigeonVar_list[1])
    let reason: String? = nilOrValue(pigeonVar_list[2])
    let timestampMs: Int64? = nilOrValue(pigeonVar_list[3])
    let payload: [String?: Any?]? = nilOrValue(pigeonVar_list[4])

    return PFlowLifecycleEvent(
      type: type,
      flowId: flowId,
      reason: reason,
      timestampMs: timestampMs,
      payload: payload
    )
  }
  func toList() -> [Any?] {
    return [
      type,
      flowId,
      reason,
      timestampMs,
      payload,
    ]
  }
  static func == (lhs: PFlowLifecycleEvent, rhs: PFlowLifecycleEvent) -> Bool {
    return deepEqualsNuxieBridge(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNuxieBridge(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PLogEvent: Hashable {
  var level: String? = nil
  var message: String? = nil
  var scope: String? = nil
  var timestampMs: Int64? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PLogEvent? {
    let level: String? = nilOrValue(pigeonVar_list[0])
    let message: String? = nilOrValue(pigeonVar_list[1])
    let scope: String? = nilOrValue(pigeonVar_list[2])
    let timestampMs: Int64? = nilOrValue(pigeonVar_list[3])

    return PLogEvent(
      level: level,
      message: message,
      scope: scope,
      timestampMs: timestampMs
    )
  }
  func toList() -> [Any?] {
    return [
      level,
      message,
      scope,
      timestampMs,
    ]
  }
  static func == (lhs: PLogEvent, rhs: PLogEvent) -> Bool {
    return deepEqualsNuxieBridge(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNuxieBridge(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PPurchaseRequest: Hashable {
  var requestId: String? = nil
  var platform: String? = nil
  var productId: String? = nil
  var basePlanId: String? = nil
  var offerId: String? = nil
  var displayName: String? = nil
  var displayPrice: String? = nil
  var price: Double? = nil
  var currencyCode: String? = nil
  var timestampMs: Int64? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PPurchaseRequest? {
    let requestId: String? = nilOrValue(pigeonVar_list[0])
    let platform: String? = nilOrValue(pigeonVar_list[1])
    let productId: String? = nilOrValue(pigeonVar_list[2])
    let basePlanId: String? = nilOrValue(pigeonVar_list[3])
    let offerId: String? = nilOrValue(pigeonVar_list[4])
    let displayName: String? = nilOrValue(pigeonVar_list[5])
    let displayPrice: String? = nilOrValue(pigeonVar_list[6])
    let price: Double? = nilOrValue(pigeonVar_list[7])
    let currencyCode: String? = nilOrValue(pigeonVar_list[8])
    let timestampMs: Int64? = nilOrValue(pigeonVar_list[9])

    return PPurchaseRequest(
      requestId: requestId,
      platform: platform,
      productId: productId,
      basePlanId: basePlanId,
      offerId: offerId,
      displayName: displayName,
      displayPrice: displayPrice,
      price: price,
      currencyCode: currencyCode,
      timestampMs: timestampMs
    )
  }
  func toList() -> [Any?] {
    return [
      requestId,
      platform,
      productId,
      basePlanId,
      offerId,
      displayName,
      displayPrice,
      price,
      currencyCode,
      timestampMs,
    ]
  }
  static func == (lhs: PPurchaseRequest, rhs: PPurchaseRequest) -> Bool {
    return deepEqualsNuxieBridge(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNuxieBridge(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PRestoreRequest: Hashable {
  var requestId: String? = nil
  var platform: String? = nil
  var timestampMs: Int64? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PRestoreRequest? {
    let requestId: String? = nilOrValue(pigeonVar_list[0])
    let platform: String? = nilOrValue(pigeonVar_list[1])
    let timestampMs: Int64? = nilOrValue(pigeonVar_list[2])

    return PRestoreRequest(
      requestId: requestId,
      platform: platform,
      timestampMs: timestampMs
    )
  }
  func toList() -> [Any?] {
    return [
      requestId,
      platform,
      timestampMs,
    ]
  }
  static func == (lhs: PRestoreRequest, rhs: PRestoreRequest) -> Bool {
    return deepEqualsNuxieBridge(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNuxieBridge(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PPurchaseResult: Hashable {
  var type: String? = nil
  var message: String? = nil
  var productId: String? = nil
  var purchaseToken: String? = nil
  var orderId: String? = nil
  var transactionId: String? = nil
  var originalTransactionId: String? = nil
  var transactionJws: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PPurchaseResult? {
    let type: String? = nilOrValue(pigeonVar_list[0])
    let message: String? = nilOrValue(pigeonVar_list[1])
    let productId: String? = nilOrValue(pigeonVar_list[2])
    let purchaseToken: String? = nilOrValue(pigeonVar_list[3])
    let orderId: String? = nilOrValue(pigeonVar_list[4])
    let transactionId: String? = nilOrValue(pigeonVar_list[5])
    let originalTransactionId: String? = nilOrValue(pigeonVar_list[6])
    let transactionJws: String? = nilOrValue(pigeonVar_list[7])

    return PPurchaseResult(
      type: type,
      message: message,
      productId: productId,
      purchaseToken: purchaseToken,
      orderId: orderId,
      transactionId: transactionId,
      originalTransactionId: originalTransactionId,
      transactionJws: transactionJws
    )
  }
  func toList() -> [Any?] {
    return [
      type,
      message,
      productId,
      purchaseToken,
      orderId,
      transactionId,
      originalTransactionId,
      transactionJws,
    ]
  }
  static func == (lhs: PPurchaseResult, rhs: PPurchaseResult) -> Bool {
    return deepEqualsNuxieBridge(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNuxieBridge(value: toList(), hasher: &hasher)
  }
}

/// Generated class from Pigeon that represents data sent in messages.
struct PRestoreResult: Hashable {
  var type: String? = nil
  var restoredCount: Int64? = nil
  var message: String? = nil


  // swift-format-ignore: AlwaysUseLowerCamelCase
  static func fromList(_ pigeonVar_list: [Any?]) -> PRestoreResult? {
    let type: String? = nilOrValue(pigeonVar_list[0])
    let restoredCount: Int64? = nilOrValue(pigeonVar_list[1])
    let message: String? = nilOrValue(pigeonVar_list[2])

    return PRestoreResult(
      type: type,
      restoredCount: restoredCount,
      message: message
    )
  }
  func toList() -> [Any?] {
    return [
      type,
      restoredCount,
      message,
    ]
  }
  static func == (lhs: PRestoreResult, rhs: PRestoreResult) -> Bool {
    return deepEqualsNuxieBridge(lhs.toList(), rhs.toList())  }
  func hash(into hasher: inout Hasher) {
    deepHashNuxieBridge(value: toList(), hasher: &hasher)
  }
}

private class NuxieBridgePigeonCodecReader: FlutterStandardReader {
  override func readValue(ofType type: UInt8) -> Any? {
    switch type {
    case 129:
      return PConfigureRequest.fromList(self.readValue() as! [Any?])
    case 130:
      return PTriggerRequest.fromList(self.readValue() as! [Any?])
    case 131:
      return PTriggerUpdate.fromList(self.readValue() as! [Any?])
    case 132:
      return PFeatureAccess.fromList(self.readValue() as! [Any?])
    case 133:
      return PFeatureCheckResult.fromList(self.readValue() as! [Any?])
    case 134:
      return PFeatureUsageResult.fromList(self.readValue() as! [Any?])
    case 135:
      return PProfileResponse.fromList(self.readValue() as! [Any?])
    case 136:
      return PFeatureAccessChangedEvent.fromList(self.readValue() as! [Any?])
    case 137:
      return PFlowLifecycleEvent.fromList(self.readValue() as! [Any?])
    case 138:
      return PLogEvent.fromList(self.readValue() as! [Any?])
    case 139:
      return PPurchaseRequest.fromList(self.readValue() as! [Any?])
    case 140:
      return PRestoreRequest.fromList(self.readValue() as! [Any?])
    case 141:
      return PPurchaseResult.fromList(self.readValue() as! [Any?])
    case 142:
      return PRestoreResult.fromList(self.readValue() as! [Any?])
    default:
      return super.readValue(ofType: type)
    }
  }
}

private class NuxieBridgePigeonCodecWriter: FlutterStandardWriter {
  override func writeValue(_ value: Any) {
    if let value = value as? PConfigureRequest {
      super.writeByte(129)
      super.writeValue(value.toList())
    } else if let value = value as? PTriggerRequest {
      super.writeByte(130)
      super.writeValue(value.toList())
    } else if let value = value as? PTriggerUpdate {
      super.writeByte(131)
      super.writeValue(value.toList())
    } else if let value = value as? PFeatureAccess {
      super.writeByte(132)
      super.writeValue(value.toList())
    } else if let value = value as? PFeatureCheckResult {
      super.writeByte(133)
      super.writeValue(value.toList())
    } else if let value = value as? PFeatureUsageResult {
      super.writeByte(134)
      super.writeValue(value.toList())
    } else if let value = value as? PProfileResponse {
      super.writeByte(135)
      super.writeValue(value.toList())
    } else if let value = value as? PFeatureAccessChangedEvent {
      super.writeByte(136)
      super.writeValue(value.toList())
    } else if let value = value as? PFlowLifecycleEvent {
      super.writeByte(137)
      super.writeValue(value.toList())
    } else if let value = value as? PLogEvent {
      super.writeByte(138)
      super.writeValue(value.toList())
    } else if let value = value as? PPurchaseRequest {
      super.writeByte(139)
      super.writeValue(value.toList())
    } else if let value = value as? PRestoreRequest {
      super.writeByte(140)
      super.writeValue(value.toList())
    } else if let value = value as? PPurchaseResult {
      super.writeByte(141)
      super.writeValue(value.toList())
    } else if let value = value as? PRestoreResult {
      super.writeByte(142)
      super.writeValue(value.toList())
    } else {
      super.writeValue(value)
    }
  }
}

private class NuxieBridgePigeonCodecReaderWriter: FlutterStandardReaderWriter {
  override func reader(with data: Data) -> FlutterStandardReader {
    return NuxieBridgePigeonCodecReader(data: data)
  }

  override func writer(with data: NSMutableData) -> FlutterStandardWriter {
    return NuxieBridgePigeonCodecWriter(data: data)
  }
}

class NuxieBridgePigeonCodec: FlutterStandardMessageCodec, @unchecked Sendable {
  static let shared = NuxieBridgePigeonCodec(readerWriter: NuxieBridgePigeonCodecReaderWriter())
}


/// Generated protocol from Pigeon that represents a handler of messages from Flutter.
protocol PNuxieHostApi {
  func configure(request: PConfigureRequest, completion: @escaping (Result<Void, Error>) -> Void)
  func shutdown(completion: @escaping (Result<Void, Error>) -> Void)
  func identify(distinctId: String, userProperties: [String?: Any?]?, userPropertiesSetOnce: [String?: Any?]?, completion: @escaping (Result<Void, Error>) -> Void)
  func reset(keepAnonymousId: Bool, completion: @escaping (Result<Void, Error>) -> Void)
  func getDistinctId(completion: @escaping (Result<String, Error>) -> Void)
  func getAnonymousId(completion: @escaping (Result<String, Error>) -> Void)
  func getIsIdentified(completion: @escaping (Result<Bool, Error>) -> Void)
  func startTrigger(request: PTriggerRequest, completion: @escaping (Result<Void, Error>) -> Void)
  func cancelTrigger(requestId: String, completion: @escaping (Result<Void, Error>) -> Void)
  func showFlow(flowId: String, completion: @escaping (Result<Void, Error>) -> Void)
  func refreshProfile(completion: @escaping (Result<PProfileResponse, Error>) -> Void)
  func hasFeature(featureId: String, requiredBalance: Int64?, entityId: String?, completion: @escaping (Result<PFeatureAccess, Error>) -> Void)
  func getCachedFeature(featureId: String, entityId: String?, completion: @escaping (Result<PFeatureAccess?, Error>) -> Void)
  func checkFeature(featureId: String, requiredBalance: Int64?, entityId: String?, completion: @escaping (Result<PFeatureCheckResult, Error>) -> Void)
  func refreshFeature(featureId: String, requiredBalance: Int64?, entityId: String?, completion: @escaping (Result<PFeatureCheckResult, Error>) -> Void)
  func useFeature(featureId: String, amount: Double, entityId: String?, metadata: [String?: Any?]?, completion: @escaping (Result<Void, Error>) -> Void)
  func useFeatureAndWait(featureId: String, amount: Double, entityId: String?, setUsage: Bool, metadata: [String?: Any?]?, completion: @escaping (Result<PFeatureUsageResult, Error>) -> Void)
  func flushEvents(completion: @escaping (Result<Bool, Error>) -> Void)
  func getQueuedEventCount(completion: @escaping (Result<Int64, Error>) -> Void)
  func pauseEventQueue(completion: @escaping (Result<Void, Error>) -> Void)
  func resumeEventQueue(completion: @escaping (Result<Void, Error>) -> Void)
  func completePurchase(requestId: String, result: PPurchaseResult, completion: @escaping (Result<Void, Error>) -> Void)
  func completeRestore(requestId: String, result: PRestoreResult, completion: @escaping (Result<Void, Error>) -> Void)
}

/// Generated setup class from Pigeon to handle messages through the `binaryMessenger`.
class PNuxieHostApiSetup {
  static var codec: FlutterStandardMessageCodec { NuxieBridgePigeonCodec.shared }
  /// Sets up an instance of `PNuxieHostApi` to handle messages through the `binaryMessenger`.
  static func setUp(binaryMessenger: FlutterBinaryMessenger, api: PNuxieHostApi?, messageChannelSuffix: String = "") {
    let channelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
    let configureChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nuxie_flutter_native.PNuxieHostApi.configure\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      configureChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let requestArg = args[0] as! PConfigureRequest
        api.configure(request: requestArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      configureChannel.setMessageHandler(nil)
    }
    let shutdownChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nuxie_flutter_native.PNuxieHostApi.shutdown\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      shutdownChannel.setMessageHandler { _, reply in
        api.shutdown { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      shutdownChannel.setMessageHandler(nil)
    }
    let identifyChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nuxie_flutter_native.PNuxieHostApi.identify\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      identifyChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let distinctIdArg = args[0] as! String
        let userPropertiesArg: [String?: Any?]? = nilOrValue(args[1])
        let userPropertiesSetOnceArg: [String?: Any?]? = nilOrValue(args[2])
        api.identify(distinctId: distinctIdArg, userProperties: userPropertiesArg, userPropertiesSetOnce: userPropertiesSetOnceArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      identifyChannel.setMessageHandler(nil)
    }
    let resetChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nuxie_flutter_native.PNuxieHostApi.reset\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      resetChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let keepAnonymousIdArg = args[0] as! Bool
        api.reset(keepAnonymousId: keepAnonymousIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      resetChannel.setMessageHandler(nil)
    }
    let getDistinctIdChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nuxie_flutter_native.PNuxieHostApi.getDistinctId\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getDistinctIdChannel.setMessageHandler { _, reply in
        api.getDistinctId { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getDistinctIdChannel.setMessageHandler(nil)
    }
    let getAnonymousIdChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nuxie_flutter_native.PNuxieHostApi.getAnonymousId\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getAnonymousIdChannel.setMessageHandler { _, reply in
        api.getAnonymousId { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getAnonymousIdChannel.setMessageHandler(nil)
    }
    let getIsIdentifiedChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nuxie_flutter_native.PNuxieHostApi.getIsIdentified\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getIsIdentifiedChannel.setMessageHandler { _, reply in
        api.getIsIdentified { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getIsIdentifiedChannel.setMessageHandler(nil)
    }
    let startTriggerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nuxie_flutter_native.PNuxieHostApi.startTrigger\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      startTriggerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let requestArg = args[0] as! PTriggerRequest
        api.startTrigger(request: requestArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      startTriggerChannel.setMessageHandler(nil)
    }
    let cancelTriggerChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nuxie_flutter_native.PNuxieHostApi.cancelTrigger\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      cancelTriggerChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let requestIdArg = args[0] as! String
        api.cancelTrigger(requestId: requestIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      cancelTriggerChannel.setMessageHandler(nil)
    }
    let showFlowChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nuxie_flutter_native.PNuxieHostApi.showFlow\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      showFlowChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let flowIdArg = args[0] as! String
        api.showFlow(flowId: flowIdArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      showFlowChannel.setMessageHandler(nil)
    }
    let refreshProfileChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nuxie_flutter_native.PNuxieHostApi.refreshProfile\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      refreshProfileChannel.setMessageHandler { _, reply in
        api.refreshProfile { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      refreshProfileChannel.setMessageHandler(nil)
    }
    let hasFeatureChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nuxie_flutter_native.PNuxieHostApi.hasFeature\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      hasFeatureChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let featureIdArg = args[0] as! String
        let requiredBalanceArg: Int64? = nilOrValue(args[1])
        let entityIdArg: String? = nilOrValue(args[2])
        api.hasFeature(featureId: featureIdArg, requiredBalance: requiredBalanceArg, entityId: entityIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      hasFeatureChannel.setMessageHandler(nil)
    }
    let getCachedFeatureChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nuxie_flutter_native.PNuxieHostApi.getCachedFeature\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getCachedFeatureChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let featureIdArg = args[0] as! String
        let entityIdArg: String? = nilOrValue(args[1])
        api.getCachedFeature(featureId: featureIdArg, entityId: entityIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getCachedFeatureChannel.setMessageHandler(nil)
    }
    let checkFeatureChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nuxie_flutter_native.PNuxieHostApi.checkFeature\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      checkFeatureChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let featureIdArg = args[0] as! String
        let requiredBalanceArg: Int64? = nilOrValue(args[1])
        let entityIdArg: String? = nilOrValue(args[2])
        api.checkFeature(featureId: featureIdArg, requiredBalance: requiredBalanceArg, entityId: entityIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      checkFeatureChannel.setMessageHandler(nil)
    }
    let refreshFeatureChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nuxie_flutter_native.PNuxieHostApi.refreshFeature\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      refreshFeatureChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let featureIdArg = args[0] as! String
        let requiredBalanceArg: Int64? = nilOrValue(args[1])
        let entityIdArg: String? = nilOrValue(args[2])
        api.refreshFeature(featureId: featureIdArg, requiredBalance: requiredBalanceArg, entityId: entityIdArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      refreshFeatureChannel.setMessageHandler(nil)
    }
    let useFeatureChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nuxie_flutter_native.PNuxieHostApi.useFeature\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      useFeatureChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let featureIdArg = args[0] as! String
        let amountArg = args[1] as! Double
        let entityIdArg: String? = nilOrValue(args[2])
        let metadataArg: [String?: Any?]? = nilOrValue(args[3])
        api.useFeature(featureId: featureIdArg, amount: amountArg, entityId: entityIdArg, metadata: metadataArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      useFeatureChannel.setMessageHandler(nil)
    }
    let useFeatureAndWaitChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nuxie_flutter_native.PNuxieHostApi.useFeatureAndWait\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      useFeatureAndWaitChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let featureIdArg = args[0] as! String
        let amountArg = args[1] as! Double
        let entityIdArg: String? = nilOrValue(args[2])
        let setUsageArg = args[3] as! Bool
        let metadataArg: [String?: Any?]? = nilOrValue(args[4])
        api.useFeatureAndWait(featureId: featureIdArg, amount: amountArg, entityId: entityIdArg, setUsage: setUsageArg, metadata: metadataArg) { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      useFeatureAndWaitChannel.setMessageHandler(nil)
    }
    let flushEventsChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nuxie_flutter_native.PNuxieHostApi.flushEvents\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      flushEventsChannel.setMessageHandler { _, reply in
        api.flushEvents { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      flushEventsChannel.setMessageHandler(nil)
    }
    let getQueuedEventCountChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nuxie_flutter_native.PNuxieHostApi.getQueuedEventCount\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      getQueuedEventCountChannel.setMessageHandler { _, reply in
        api.getQueuedEventCount { result in
          switch result {
          case .success(let res):
            reply(wrapResult(res))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      getQueuedEventCountChannel.setMessageHandler(nil)
    }
    let pauseEventQueueChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nuxie_flutter_native.PNuxieHostApi.pauseEventQueue\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      pauseEventQueueChannel.setMessageHandler { _, reply in
        api.pauseEventQueue { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      pauseEventQueueChannel.setMessageHandler(nil)
    }
    let resumeEventQueueChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nuxie_flutter_native.PNuxieHostApi.resumeEventQueue\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      resumeEventQueueChannel.setMessageHandler { _, reply in
        api.resumeEventQueue { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      resumeEventQueueChannel.setMessageHandler(nil)
    }
    let completePurchaseChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nuxie_flutter_native.PNuxieHostApi.completePurchase\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      completePurchaseChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let requestIdArg = args[0] as! String
        let resultArg = args[1] as! PPurchaseResult
        api.completePurchase(requestId: requestIdArg, result: resultArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      completePurchaseChannel.setMessageHandler(nil)
    }
    let completeRestoreChannel = FlutterBasicMessageChannel(name: "dev.flutter.pigeon.nuxie_flutter_native.PNuxieHostApi.completeRestore\(channelSuffix)", binaryMessenger: binaryMessenger, codec: codec)
    if let api = api {
      completeRestoreChannel.setMessageHandler { message, reply in
        let args = message as! [Any?]
        let requestIdArg = args[0] as! String
        let resultArg = args[1] as! PRestoreResult
        api.completeRestore(requestId: requestIdArg, result: resultArg) { result in
          switch result {
          case .success:
            reply(wrapResult(nil))
          case .failure(let error):
            reply(wrapError(error))
          }
        }
      }
    } else {
      completeRestoreChannel.setMessageHandler(nil)
    }
  }
}
/// Generated protocol from Pigeon that represents Flutter messages that can be called from Swift.
protocol PNuxieFlutterApiProtocol {
  func onTriggerUpdate(event eventArg: PTriggerUpdate, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onFeatureAccessChanged(event eventArg: PFeatureAccessChangedEvent, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onFlowLifecycle(event eventArg: PFlowLifecycleEvent, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onLog(event eventArg: PLogEvent, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onPurchaseRequest(request requestArg: PPurchaseRequest, completion: @escaping (Result<Void, PigeonError>) -> Void)
  func onRestoreRequest(request requestArg: PRestoreRequest, completion: @escaping (Result<Void, PigeonError>) -> Void)
}
class PNuxieFlutterApi: PNuxieFlutterApiProtocol {
  private let binaryMessenger: FlutterBinaryMessenger
  private let messageChannelSuffix: String
  init(binaryMessenger: FlutterBinaryMessenger, messageChannelSuffix: String = "") {
    self.binaryMessenger = binaryMessenger
    self.messageChannelSuffix = messageChannelSuffix.count > 0 ? ".\(messageChannelSuffix)" : ""
  }
  var codec: NuxieBridgePigeonCodec {
    return NuxieBridgePigeonCodec.shared
  }
  func onTriggerUpdate(event eventArg: PTriggerUpdate, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nuxie_flutter_native.PNuxieFlutterApi.onTriggerUpdate\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([eventArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onFeatureAccessChanged(event eventArg: PFeatureAccessChangedEvent, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nuxie_flutter_native.PNuxieFlutterApi.onFeatureAccessChanged\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([eventArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onFlowLifecycle(event eventArg: PFlowLifecycleEvent, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nuxie_flutter_native.PNuxieFlutterApi.onFlowLifecycle\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([eventArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onLog(event eventArg: PLogEvent, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nuxie_flutter_native.PNuxieFlutterApi.onLog\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([eventArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onPurchaseRequest(request requestArg: PPurchaseRequest, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nuxie_flutter_native.PNuxieFlutterApi.onPurchaseRequest\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([requestArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
  func onRestoreRequest(request requestArg: PRestoreRequest, completion: @escaping (Result<Void, PigeonError>) -> Void) {
    let channelName: String = "dev.flutter.pigeon.nuxie_flutter_native.PNuxieFlutterApi.onRestoreRequest\(messageChannelSuffix)"
    let channel = FlutterBasicMessageChannel(name: channelName, binaryMessenger: binaryMessenger, codec: codec)
    channel.sendMessage([requestArg] as [Any?]) { response in
      guard let listResponse = response as? [Any?] else {
        completion(.failure(createConnectionError(withChannelName: channelName)))
        return
      }
      if listResponse.count > 1 {
        let code: String = listResponse[0] as! String
        let message: String? = nilOrValue(listResponse[1])
        let details: String? = nilOrValue(listResponse[2])
        completion(.failure(PigeonError(code: code, message: message, details: details)))
      } else {
        completion(.success(()))
      }
    }
  }
}
